// Generated by CoffeeScript 1.6.3
(function() {
  var M, Parser, Source, fillArray, key, matcherGenerator, parser, src, _ref,
    __slice = [].slice;

  fillArray = function(filler, length) {
    return Array.apply(null, new Array(length)).map(function() {
      return fillter;
    });
  };

  Source = (function() {
    function Source(str) {
      this.str = str;
      this.pos = 0;
    }

    Source.prototype.consume = function(length) {
      var part;
      part = this.str.slice(this.pos, this.pos + length);
      this.pos += length;
      return part;
    };

    Source.prototype.peek = function(length) {
      return this.str.slice(this.pos, this.pos + length);
    };

    Source.prototype.current = function() {
      return this.str.slice(this.pos);
    };

    Source.prototype.clone = function() {
      var src;
      src = new Source;
      src.initCopy(this);
      return src;
    };

    Source.prototype.initCopy = function(parent) {
      this.str = parent.str;
      return this.pos = parent.pos;
    };

    return Source;

  })();

  M = function(matcherGenerator) {
    return function() {
      var args, matcher, rawMatcher,
        _this = this;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      rawMatcher = matcherGenerator.apply(this, args);
      matcher = function(src) {
        return rawMatcher.call(this, src);
      };
      matcher.repeat = function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return _this.repeat.apply(_this, [matcher].concat(__slice.call(args)));
      };
      matcher.then = function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return _this.add.apply(_this, [matcher].concat(__slice.call(args)));
      };
      matcher.or = function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return _this.or.apply(_this, [matcher].concat(__slice.call(args)));
      };
      matcher.map = function(fn) {
        var prevMatcher;
        prevMatcher = rawMatcher;
        rawMatcher = function(src) {
          var match;
          match = prevMatcher.call(_this, src);
          if (match.matched) {
            match.result = fn.apply(null, match.result);
          }
          return match;
        };
        return matcher;
      };
      return matcher;
    };
  };

  Parser = (function() {
    function Parser(fn) {
      if (fn != null) {
        if (typeof fn.call === "function") {
          fn.call(this);
        }
      }
    }

    Parser.prototype.string = function(str) {
      var _this = this;
      return function(src) {
        if (src.peek(str.length) === str) {
          src.consume(str.length);
          return {
            matched: true,
            consumed: str.length,
            result: [str]
          };
        } else {
          return {
            matched: false
          };
        }
      };
    };

    Parser.prototype.regexp = function(re) {
      var _this = this;
      return function(src) {
        var match;
        re.lastIndex = 0;
        match = re.exec(src.current());
        if (match) {
          src.consume(match[0].length);
          return {
            matched: true,
            consumed: match[0].length,
            result: match
          };
        } else {
          return {
            matched: false
          };
        }
      };
    };

    Parser.prototype.add = function() {
      var matchers,
        _this = this;
      matchers = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return function(src) {
        var consumed, lastResult, match, matcher, results, _i, _len;
        results = [];
        consumed = 0;
        for (_i = 0, _len = matchers.length; _i < _len; _i++) {
          matcher = matchers[_i];
          match = matcher(src);
          if (match.matched) {
            lastResult = results[results.length - 1];
            if ((lastResult != null) && lastResult.length === 1 && typeof lastResult[0] === 'string' && match.result.length === 1 && typeof match.result[0] === 'string') {
              lastResult[0] += match.result[0];
            } else {
              results.push(match.result);
            }
            consumed += match.consumed;
          } else {
            return {
              matched: false
            };
          }
        }
        return {
          matched: true,
          consumed: consumed,
          result: results.map(function(input) {
            if ((input != null) && input.length === 1) {
              return input[0];
            } else {
              return input;
            }
          })
        };
      };
    };

    Parser.prototype.or = function() {
      var matchers,
        _this = this;
      matchers = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return function(src) {
        var match, matcher, _i, _len;
        for (_i = 0, _len = matchers.length; _i < _len; _i++) {
          matcher = matchers[_i];
          match = matcher(src);
          if (match.matched) {
            return match;
          }
        }
        return {
          matched: false
        };
      };
    };

    Parser.prototype.repeat = function(matcher, num, expansion) {
      var _this = this;
      if (num == null) {
        num = 0;
      }
      if (expansion == null) {
        expansion = num === 0 ? 1 : 0;
      }
      return function(src) {
        var consumed, lastResult, match, results;
        results = [];
        consumed = 0;
        while (true) {
          match = matcher(src);
          if (match.matched) {
            if (expansion < 0 && results.length >= num) {
              return {
                matched: false
              };
            }
            lastResult = results[results.length - 1];
            if ((lastResult != null) && lastResult.length === 1 && typeof lastResult[0] === 'string' && match.result.length === 1 && typeof match.result[0] === 'string') {
              lastResult[0] += match.result[0];
            } else {
              results.push(match.result);
            }
            consumed += match.consumed;
          } else if (expansion >= 0 && results.length < num) {
            return {
              matched: false
            };
          } else {
            break;
          }
        }
        return {
          matched: true,
          consumed: consumed,
          result: results.map(function(input) {
            if ((input != null) && input.length === 1) {
              return input[0];
            } else {
              return input;
            }
          })
        };
      };
    };

    Parser.prototype.O = function() {
      var a;
      a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.or.apply(this, a);
    };

    Parser.prototype.str = function() {
      var a;
      a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.string.apply(this, a);
    };

    Parser.prototype.S = function() {
      var a;
      a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.string.apply(this, a);
    };

    Parser.prototype.re = function() {
      var a;
      a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.regexp.apply(this, a);
    };

    Parser.prototype.R = function() {
      var a;
      a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.regexp.apply(this, a);
    };

    Parser.prototype.A = function() {
      var a;
      a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.add.apply(this, a);
    };

    return Parser;

  })();

  _ref = Parser.prototype;
  for (key in _ref) {
    matcherGenerator = _ref[key];
    Parser.prototype[key] = M(matcherGenerator);
  }

  parser = new Parser(function() {
    this.blockBody = this.A(this.S('if'), this.S(' ').repeat(), this.S('this'));
    return this.root = this.blockBody;
  });

  src = new Source('if this.works then print("it works") end');

  console.log(parser.root(src));

  console.log(src.current());

}).call(this);
